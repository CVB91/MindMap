---
title: 'My Kneipe: An app for exploring the best bars in Berlin'
date: '2023-02-23 '
excerpt: "A fullstack web app"
isFeatured: true
---
 ## My Kneipe: the process and the challenges


Building a full-stack web application was an exciting and challenging process that required careful planning and execution. In this blog post, I will explore the process of building "My Kneipe," a web application that allowed users to upload and rate their favorite bars in Berlin. The technologies I used in this project included Next Js, Typescript, Prisma, Graphql, TypeGraphQL, PostgreSQL database on Supabase, Cloudinary for Images, and Firebase for authentication.

The first step in building any web application was to define the problem I was trying to solve and the features I wanted to include. In the case of My Kneipe, the goal was to create a platform where users could discover and rate the best bars in Berlin. The features of the application included a user-friendly interface for uploading and browsing bars, a rating system for users to rate and review bars, and a backend database to store and manage user data.

Once the features and requirements had been defined, the next step was to choose the appropriate technology stack. For My Kneipe, I chose to use Next Js, Typescript, Prisma, Graphql, TypeGraphQL, PostgreSQL database on Supabase, Cloudinary for Images, and Firebase for authentication. These technologies provided a robust set of tools for building a web application with a back-end server, database, and front-end user interface.

The next step in the process was to design the database schema and set up the database. This involved deciding on the tables, columns, and relationships needed to store user data and bar information. I used Supabase as my database management system, which provided a powerful set of features for creating and managing databases.

After setting up the database, the next step was to create the server-side code using Typescript, Prisma, Graphql, and TypeGraphQL. This involved writing the resolvers, mutations, and queries needed to handle user requests and interact with the database. I also implemented authentication and authorization to ensure that only authorized users could access the application and their data.

Finally, I created the front-end user interface using Next Js and React. This involved designing the layout and user experience of the application, as well as integrating the server-side code with the client-side code. I also used Cloudinary to store and manage images of bars, which were displayed on the front-end interface.

Throughout the process of building My Kneipe, there were several challenges that I needed to overcome. These included ensuring the security and reliability of the application, optimizing performance and scalability, and testing and debugging the code to ensure that it functioned correctly. I also incorporated user feedback and iterated on the design and functionality of the application to ensure that it met the needs of our target audience.

In conclusion, building a full-stack web application like My Kneipe was a complex and challenging process that required careful planning and execution. By using the appropriate technology stack and following best practices for security, reliability, and performance, I was able to create a web application that provided value to users and helped promote the best bars in Berlin.

Regarding the choice of technology stack, I chose Next Js, Typescript, Prisma, Graphql, TypeGraphQL, PostgreSQL database on Supabase, Cloudinary for Images, and Firebase for authentication because they provided a modern and scalable architecture that was easy to maintain and extend. The use of TypeScript, Prisma, GraphQL, and TypeGraphQL provided a type-safe and efficient development experience, while the use of Supabase, Cloudinary, and Firebase provided a reliable and scalable backend infrastructure.